-- ==========================================
-- PEERCONNECT COMPLETE DATABASE SCHEMA
-- ==========================================
-- This script reconstructs the entire PeerConnect backend.
-- Run this once in the Supabase SQL Editor to set up your project.

-- 1. EXTENSIONS
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2. PROFILES TABLE (Linked to auth.users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  full_name text,
  verified boolean DEFAULT false,
  avatar_url text,
  push_token text
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Trigger to automatically create a profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 3. COURSE TABLE
CREATE TABLE IF NOT EXISTS public."Course" (
  course_id text PRIMARY KEY
);
ALTER TABLE public."Course" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Courses are viewable by everyone." ON public."Course" FOR SELECT USING (true);

INSERT INTO public."Course" (course_id) VALUES 
('ELEC 101'), ('ELEC 102'), ('MECH 201'), ('CIVL 301'), ('SOFT 401'), ('SOFT 402'), ('CPRG303')
ON CONFLICT DO NOTHING;

-- 4. REQUEST TABLE
CREATE TABLE IF NOT EXISTS public.request (
  request_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  course_id text REFERENCES public."Course"(course_id) NOT NULL,
  title text NOT NULL,
  description text NOT NULL,
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'booked', 'completed')),
  create_date timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  assigned_to uuid REFERENCES public.profiles(id)
);
ALTER TABLE public.request ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Requests are viewable by everyone." ON public.request FOR SELECT USING (true);
CREATE POLICY "Users can create requests." ON public.request FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own requests." ON public.request FOR UPDATE USING (auth.uid() = user_id OR auth.uid() = assigned_to);
CREATE POLICY "Users can delete their own requests." ON public.request FOR DELETE USING (auth.uid() = user_id);

-- 5. BOOKINGS TABLE (With Escrow support)
CREATE TABLE IF NOT EXISTS public.bookings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  requester_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  provider_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title text NOT NULL,
  date timestamp with time zone NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'completed', 'canceled')),
  price numeric DEFAULT 0,
  location text,
  request_id bigint REFERENCES public.request(request_id) ON DELETE SET NULL,
  payment_status text DEFAULT 'pending' CHECK (payment_status IN ('pending', 'escrow', 'released', 'disputed'))
);
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own bookings." ON public.bookings FOR SELECT USING (auth.uid() = requester_id OR auth.uid() = provider_id);
CREATE POLICY "Users can create bookings." ON public.bookings FOR INSERT WITH CHECK (auth.uid() = requester_id OR auth.uid() = provider_id);
CREATE POLICY "Users can update their own bookings." ON public.bookings FOR UPDATE USING (auth.uid() = requester_id OR auth.uid() = provider_id);

-- 6. MESSAGES TABLE
CREATE TABLE IF NOT EXISTS public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  receiver_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  content text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  is_read boolean DEFAULT false,
  safety_analysis jsonb
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own messages." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update messages they received." ON public.messages FOR UPDATE USING (auth.uid() = receiver_id);

-- 7. TRANSACTIONS TABLE (Mock Payments)
CREATE TABLE IF NOT EXISTS public.transactions (
  id text PRIMARY KEY,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  receiver_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  amount numeric NOT NULL,
  status text NOT NULL CHECK (status IN ('pending', 'completed', 'failed')),
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  reference_id text
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert transactions they authored" ON public.transactions FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- 8. REVIEWS TABLE
CREATE TABLE IF NOT EXISTS public.reviews (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reviewer_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  reviewee_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  booking_id bigint REFERENCES public.bookings(id) ON DELETE SET NULL,
  rating smallint NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are viewable by everyone." ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Users can create reviews" ON public.reviews FOR INSERT WITH CHECK (auth.uid() = reviewer_id);

-- 9. AVAILABILITY TABLE
CREATE TABLE IF NOT EXISTS public.availability (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    day_of_week text NOT NULL CHECK (day_of_week IN ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
    start_time text NOT NULL, -- Format: HH:MM
    end_time text NOT NULL,   -- Format: HH:MM
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.availability ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their availability" ON public.availability FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Anyone can view availability" ON public.availability FOR SELECT USING (true);

-- 10. NOTIFICATIONS TABLE
CREATE TABLE IF NOT EXISTS public.notifications (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  type text NOT NULL,
  content text NOT NULL,
  data jsonb,
  is_read boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own notifications." ON public.notifications FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Anyone can create notifications." ON public.notifications FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can update their own notifications." ON public.notifications FOR UPDATE USING (auth.uid() = user_id);

-- 11. REPORTS TABLE (Flagging System)
CREATE TABLE IF NOT EXISTS public.reports (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    reporter_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    target_type text NOT NULL CHECK (target_type IN ('message', 'request', 'user')),
    target_id text NOT NULL,
    reason text NOT NULL,
    status text DEFAULT 'pending' CHECK (status IN ('pending', 'reviewed', 'resolved')),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can create reports" ON public.reports FOR INSERT WITH CHECK (auth.uid() = reporter_id);
CREATE POLICY "Admins can view reports" ON public.reports FOR SELECT USING (true);
CREATE POLICY "Admins can update reports" ON public.reports FOR UPDATE USING (true);

-- 12. STORAGE BUCKET FOR AVATARS
-- Note: Re-run this check safely if using dashboard
INSERT INTO storage.buckets (id, name, public) VALUES ('avatars', 'avatars', true) ON CONFLICT DO NOTHING;
CREATE POLICY "Avatar images are publicly accessible." ON storage.objects FOR SELECT USING ( bucket_id = 'avatars' );
CREATE POLICY "Users can upload their own avatar." ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1] );
CREATE POLICY "Users can update their own avatar." ON storage.objects FOR UPDATE USING ( bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1] );

-- 13. ESCROW AUTO-RELEASE (Cron)
CREATE OR REPLACE FUNCTION release_expired_escrow()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE bookings
  SET payment_status = 'released'
  WHERE payment_status = 'escrow'
    AND date < (now() - interval '21 days');
END;
$$;

SELECT cron.schedule(
  'auto-release-escrows',
  '0 0 * * *',
  $$ SELECT release_expired_escrow() $$
);
