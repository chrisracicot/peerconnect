-- Complete Supabase Schema Recreation Script

-- 1. Profiles Table (Linked to auth.users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  full_name text,
  verified boolean DEFAULT false,
  avatar_url text,
  push_token text
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create a trigger to automatically create a profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 2. Course Table
CREATE TABLE IF NOT EXISTS public."Course" (
  course_id text PRIMARY KEY
);
ALTER TABLE public."Course" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Courses are viewable by everyone." ON public."Course" FOR SELECT USING (true);
-- Populate some initial courses based on the app's predefined lists
INSERT INTO public."Course" (course_id) VALUES 
('ELEC 101'), ('ELEC 102'), ('MECH 201'), ('CIVL 301'), ('SOFT 401'), ('SOFT 402'), ('CPRG303')
ON CONFLICT DO NOTHING;

-- 3. request Table
CREATE TABLE IF NOT EXISTS public.request (
  request_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  course_id text REFERENCES public."Course"(course_id) NOT NULL,
  title text NOT NULL,
  description text NOT NULL,
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'booked', 'completed')),
  create_date timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  assigned_to uuid REFERENCES public.profiles(id)
);
ALTER TABLE public.request ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Requests are viewable by everyone." ON public.request FOR SELECT USING (true);
CREATE POLICY "Users can create requests." ON public.request FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own requests." ON public.request FOR UPDATE USING (auth.uid() = user_id OR auth.uid() = assigned_to);
CREATE POLICY "Users can delete their own requests." ON public.request FOR DELETE USING (auth.uid() = user_id);

-- 4. bookings Table
CREATE TABLE IF NOT EXISTS public.bookings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  requester_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  provider_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title text NOT NULL,
  date timestamp with time zone NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'completed', 'canceled'))
);
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own bookings." ON public.bookings FOR SELECT USING (auth.uid() = requester_id OR auth.uid() = provider_id);
CREATE POLICY "Users can create bookings." ON public.bookings FOR INSERT WITH CHECK (auth.uid() = requester_id OR auth.uid() = provider_id);
CREATE POLICY "Users can update their own bookings." ON public.bookings FOR UPDATE USING (auth.uid() = requester_id OR auth.uid() = provider_id);

-- 5. messages Table
CREATE TABLE IF NOT EXISTS public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  receiver_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  content text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  is_read boolean DEFAULT false,
  safety_analysis jsonb
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own messages." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update messages they received." ON public.messages FOR UPDATE USING (auth.uid() = receiver_id);

-- 6. transactions Table (Mock Payments)
CREATE TABLE IF NOT EXISTS public.transactions (
  id text PRIMARY KEY,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  receiver_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  amount numeric NOT NULL,
  status text NOT NULL CHECK (status IN ('pending', 'completed', 'failed')),
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  reference_id text
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert transactions they authored" ON public.transactions FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- 7. reviews Table
CREATE TABLE IF NOT EXISTS public.reviews (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reviewer_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  reviewee_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  booking_id bigint REFERENCES public.bookings(id) ON DELETE SET NULL,
  rating smallint NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are viewable by everyone." ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Users can create reviews" ON public.reviews FOR INSERT WITH CHECK (auth.uid() = reviewer_id);

-- 8. Storage Bucket for Avatars
-- (This must be done manually in the UI beforehand if via UI, or programmatically if extension is enabled)
INSERT INTO storage.buckets (id, name, public) VALUES ('avatars', 'avatars', true) ON CONFLICT DO NOTHING;

CREATE POLICY "Avatar images are publicly accessible." ON storage.objects FOR SELECT USING ( bucket_id = 'avatars' );
CREATE POLICY "Users can upload their own avatar." ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1] );
CREATE POLICY "Users can update their own avatar." ON storage.objects FOR UPDATE USING ( bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1] );

